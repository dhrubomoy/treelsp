/**
 * LSP server for MiniLang
 * Generated by treelsp â€” do not edit
 */

import {
  createConnection,
  TextDocuments,
  ProposedFeatures,
  TextDocumentSyncKind,
  DiagnosticSeverity,
} from 'vscode-languageserver/node';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { createServer, createDocumentState } from 'treelsp/runtime';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import definition from '../grammar.js';

const connection = createConnection(ProposedFeatures.all);
const textDocuments = new TextDocuments(TextDocument);

const __dirname = dirname(fileURLToPath(import.meta.url));
const wasmPath = resolve(__dirname, 'grammar.wasm');

const service = createServer(definition);

const documentStates = new Map();

async function getDocumentState(textDoc) {
  let state = documentStates.get(textDoc.uri);
  if (!state) {
    state = await createDocumentState(wasmPath, {
      uri: textDoc.uri,
      version: textDoc.version,
      languageId: 'minilang',
    }, textDoc.getText());
    documentStates.set(textDoc.uri, state);
  }
  return state;
}

const severityMap = {
  error: DiagnosticSeverity.Error,
  warning: DiagnosticSeverity.Warning,
  info: DiagnosticSeverity.Information,
  hint: DiagnosticSeverity.Hint,
};

async function validateDocument(textDoc) {
  const state = await getDocumentState(textDoc);
  const diagnostics = service.computeDiagnostics(state);
  connection.sendDiagnostics({
    uri: textDoc.uri,
    version: textDoc.version,
    diagnostics: diagnostics.map(d => ({
      range: d.range,
      severity: severityMap[d.severity],
      message: d.message,
      code: d.code,
      source: d.source ?? 'minilang',
    })),
  });
}

connection.onInitialize(() => ({
  capabilities: {
    textDocumentSync: TextDocumentSyncKind.Full,
    hoverProvider: true,
    definitionProvider: true,
    referencesProvider: true,
    completionProvider: { resolveProvider: false },
    renameProvider: true,
    documentSymbolProvider: true,
  },
}));

textDocuments.onDidOpen(async (event) => {
  await validateDocument(event.document);
});

textDocuments.onDidChangeContent(async (event) => {
  const state = documentStates.get(event.document.uri);
  if (state) {
    state.update(event.document.getText(), event.document.version);
    service.documents.change(state);
  }
  await validateDocument(event.document);
});

textDocuments.onDidClose((event) => {
  const state = documentStates.get(event.document.uri);
  if (state) {
    service.documents.close(event.document.uri);
    state.dispose();
    documentStates.delete(event.document.uri);
  }
  connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
});

connection.onHover(async (params) => {
  const textDoc = textDocuments.get(params.textDocument.uri);
  if (!textDoc) return null;
  const state = await getDocumentState(textDoc);
  const result = service.provideHover(state, params.position);
  if (!result) return null;
  return {
    contents: { kind: 'markdown', value: result.contents },
    range: result.range,
  };
});

connection.onDefinition(async (params) => {
  const textDoc = textDocuments.get(params.textDocument.uri);
  if (!textDoc) return null;
  const state = await getDocumentState(textDoc);
  const result = service.provideDefinition(state, params.position);
  if (!result) return null;
  return { uri: result.uri, range: result.range };
});

connection.onReferences(async (params) => {
  const textDoc = textDocuments.get(params.textDocument.uri);
  if (!textDoc) return [];
  const state = await getDocumentState(textDoc);
  const results = service.provideReferences(state, params.position);
  return results.map(r => ({ uri: r.uri, range: r.range }));
});

connection.onCompletion(async (params) => {
  const textDoc = textDocuments.get(params.textDocument.uri);
  if (!textDoc) return [];
  const state = await getDocumentState(textDoc);
  return service.provideCompletion(state, params.position);
});

connection.onRenameRequest(async (params) => {
  const textDoc = textDocuments.get(params.textDocument.uri);
  if (!textDoc) return null;
  const state = await getDocumentState(textDoc);
  const result = service.provideRename(state, params.position, params.newName);
  if (!result) return null;
  const changes = {};
  for (const [uri, edits] of Object.entries(result.changes)) {
    changes[uri] = edits.map(e => ({ range: e.range, newText: e.newText }));
  }
  return { changes };
});

connection.onDocumentSymbol(async (params) => {
  const textDoc = textDocuments.get(params.textDocument.uri);
  if (!textDoc) return [];
  const state = await getDocumentState(textDoc);
  const symbols = service.provideSymbols(state);
  return symbols.map(s => ({
    name: s.name,
    kind: s.kindNumber,
    detail: s.detail,
    range: s.range,
    selectionRange: s.selectionRange,
    children: [],
  }));
});

textDocuments.listen(connection);
connection.listen();
