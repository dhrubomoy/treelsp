import { describe, it, expect } from 'vitest';
import { generateLocals } from './locals.js';
import type { LanguageDefinition } from '../../definition/index.js';

type MiniLangRules =
  | 'program' | 'statement' | 'variable_decl' | 'expr_statement'
  | 'expression' | 'binary_expr' | 'identifier' | 'number';

function createMiniLangDefinition(): LanguageDefinition<MiniLangRules> {
  return {
    name: 'MiniLang',
    fileExtensions: ['.mini'],
    entry: 'program',
    word: 'identifier',

    grammar: {
      program: r => r.repeat(r.rule('statement')),
      statement: r => r.choice(r.rule('variable_decl'), r.rule('expr_statement')),
      variable_decl: r => r.seq(
        'let',
        r.field('name', r.rule('identifier')),
        '=',
        r.field('value', r.rule('expression')),
        ';',
      ),
      expr_statement: r => r.seq(r.field('expr', r.rule('expression')), ';'),
      expression: r => r.choice(r.rule('binary_expr'), r.rule('identifier'), r.rule('number')),
      binary_expr: r => r.choice(
        r.prec.left(1, r.seq(r.field('left', r.rule('expression')), r.field('op', '+'), r.field('right', r.rule('expression')))),
        r.prec.left(1, r.seq(r.field('left', r.rule('expression')), r.field('op', '-'), r.field('right', r.rule('expression')))),
        r.prec.left(2, r.seq(r.field('left', r.rule('expression')), r.field('op', '*'), r.field('right', r.rule('expression')))),
        r.prec.left(2, r.seq(r.field('left', r.rule('expression')), r.field('op', '/'), r.field('right', r.rule('expression')))),
      ),
      identifier: r => r.token(/[a-zA-Z_][a-zA-Z0-9_]*/),
      number: r => r.token(/[0-9]+/),
    },

    semantic: {
      program: { scope: 'global' },
      variable_decl: { declares: { field: 'name', scope: 'enclosing' } },
      identifier: { references: { field: 'name', to: 'variable_decl', onUnresolved: 'error' } },
    },
  };
}

describe('generateLocals', () => {
  it('generates header comment', () => {
    const result = generateLocals(createMiniLangDefinition());
    expect(result).toContain('; Scope queries for MiniLang');
    expect(result).toContain('; Generated by treelsp');
  });

  it('generates scope entries for rules with scope', () => {
    const result = generateLocals(createMiniLangDefinition());
    expect(result).toContain('(program) @local.scope');
  });

  it('generates definition entries for rules with declares', () => {
    const result = generateLocals(createMiniLangDefinition());
    expect(result).toContain('(variable_decl name: (identifier) @local.definition)');
  });

  it('generates reference entries for leaf token rules', () => {
    const result = generateLocals(createMiniLangDefinition());
    expect(result).toContain('(identifier) @local.reference');
  });

  it('generates reference entries with field for compound rules', () => {
    const def: LanguageDefinition<'program' | 'member_expr' | 'identifier'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      word: 'identifier',
      grammar: {
        program: r => r.repeat(r.rule('member_expr')),
        member_expr: r => r.seq(
          r.field('object', r.rule('identifier')),
          '.',
          r.field('member', r.rule('identifier')),
        ),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
      semantic: {
        program: { scope: 'global' },
        member_expr: { references: { field: 'member', to: 'field_decl' } },
      },
    };
    const result = generateLocals(def);
    expect(result).toContain('(member_expr member: (identifier) @local.reference)');
  });

  it('handles multiple scope kinds', () => {
    const def: LanguageDefinition<'program' | 'block' | 'function_decl' | 'identifier'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      word: 'identifier',
      grammar: {
        program: r => r.repeat(r.rule('function_decl')),
        block: r => r.seq('{', '}'),
        function_decl: r => r.seq('fn', r.field('name', r.rule('identifier')), r.rule('block')),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
      semantic: {
        program: { scope: 'global' },
        block: { scope: 'lexical' },
        function_decl: {
          scope: 'lexical',
          declares: { field: 'name', scope: 'enclosing' },
        },
      },
    };
    const result = generateLocals(def);
    expect(result).toContain('(program) @local.scope');
    expect(result).toContain('(block) @local.scope');
    expect(result).toContain('(function_decl) @local.scope');
  });

  it('works with no semantic layer', () => {
    const def: LanguageDefinition<'program' | 'identifier'> = {
      name: 'Bare',
      fileExtensions: ['.bare'],
      entry: 'program',
      grammar: {
        program: r => r.repeat(r.rule('identifier')),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
    };
    const result = generateLocals(def);
    expect(result).toContain('; Scope queries for Bare');
    // Should have no scope/definition/reference entries
    expect(result).not.toContain('@local.scope');
    expect(result).not.toContain('@local.definition');
    expect(result).not.toContain('@local.reference');
  });

  it('produces deterministic output', () => {
    const result1 = generateLocals(createMiniLangDefinition());
    const result2 = generateLocals(createMiniLangDefinition());
    expect(result1).toBe(result2);
  });
});
