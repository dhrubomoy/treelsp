/**
 * Highlights codegen
 * Generates Tree-sitter highlights.scm from language definition
 */

import type { LanguageDefinition, SemanticRule } from '../../definition/index.js';
import type { CompletionKind } from '../../definition/lsp.js';
import {
  type RuleNode,
  buildRuleNodes,
  classifyStrings,
  isTokenRule,
  classifyTokenRule,
} from '../classify.js';

/** Mapping from CompletionKind to highlight capture name */
const COMPLETION_KIND_TO_CAPTURE: Partial<Record<CompletionKind, string>> = {
  Variable: 'variable',
  Function: 'function',
  Method: 'function.method',
  Class: 'type',
  Interface: 'type',
  Module: 'module',
  Enum: 'type',
  Constant: 'constant',
  Property: 'property',
  Field: 'property',
  Constructor: 'constructor',
};

/**
 * Find the rule name referenced inside a field node
 * Walks through prec/optional wrappers to find the rule reference
 */
function findFieldChildRule(node: RuleNode): string | null {
  switch (node.type) {
    case 'rule':
      return node.name;
    case 'optional':
    case 'repeat':
    case 'repeat1':
    case 'prec':
    case 'prec.left':
    case 'prec.right':
    case 'prec.dynamic':
    case 'token.immediate':
      return findFieldChildRule(node.rule);
    case 'alias':
      return node.name;
    default:
      return null;
  }
}

/**
 * Find the child rule name for a specific field in a rule's RuleNode tree
 */
function findFieldRuleName(node: RuleNode, fieldName: string): string | null {
  switch (node.type) {
    case 'field':
      if (node.name === fieldName) {
        return findFieldChildRule(node.rule);
      }
      return null;
    case 'seq':
    case 'choice':
      for (const child of node.rules) {
        const result = findFieldRuleName(child, fieldName);
        if (result) return result;
      }
      return null;
    case 'optional':
    case 'repeat':
    case 'repeat1':
    case 'token.immediate':
      return findFieldRuleName(node.rule, fieldName);
    case 'prec':
    case 'prec.left':
    case 'prec.right':
    case 'prec.dynamic':
      return findFieldRuleName(node.rule, fieldName);
    case 'alias':
      return findFieldRuleName(node.rule, fieldName);
    default:
      return null;
  }
}

/**
 * Generate Tree-sitter highlights.scm from language definition
 */
export function generateHighlights<T extends string>(
  definition: LanguageDefinition<T>
): string {
  const { rules } = buildRuleNodes(definition.grammar as Record<string, any>);

  const semantic: Record<string, SemanticRule | undefined> = definition.semantic ?? {};
  const lsp = definition.lsp;

  // Classify string literals
  const { keywords: keywordStrings, operators: operatorStrings, brackets: bracketStrings, delimiters: delimiterStrings } =
    classifyStrings(rules, lsp?.$keywords);

  // Declaration name captures
  const declarationCaptures: string[] = [];
  for (const [ruleName, semanticRule] of Object.entries(semantic)) {
    if (!semanticRule?.declares) continue;
    const fieldName = semanticRule.declares.field;

    // Find what rule the field wraps
    const ruleNode = rules[ruleName];
    if (!ruleNode) continue;
    const childRuleName = findFieldRuleName(ruleNode, fieldName);
    if (!childRuleName) continue;

    // Determine highlight capture from LSP completionKind
    let capture = 'variable'; // default
    const lspRule = lsp?.[ruleName as T];
    if (lspRule?.completionKind) {
      capture = COMPLETION_KIND_TO_CAPTURE[lspRule.completionKind] ?? 'variable';
    }

    declarationCaptures.push(`(${ruleName} ${fieldName}: (${childRuleName}) @${capture})`);
  }

  // Token rule captures (number, string, comment, etc.)
  const literalCaptures: string[] = [];
  const identifierCaptures: string[] = [];
  for (const [ruleName, ruleNode] of Object.entries(rules)) {
    if (!isTokenRule(ruleNode)) continue;

    const tokenClass = classifyTokenRule(ruleName);
    if (tokenClass) {
      literalCaptures.push(`(${ruleName}) @${tokenClass}`);
    } else if (ruleName === definition.word) {
      // The word rule (identifier) goes last as fallback
      identifierCaptures.push(`(${ruleName}) @variable`);
    } else {
      // Other token rules without classification — check if it has semantic references
      const semRule = semantic[ruleName as T];
      if (semRule?.references) {
        identifierCaptures.push(`(${ruleName}) @variable`);
      }
    }
  }

  // Build output
  const sections: string[] = [];

  sections.push(`; Syntax highlighting for ${definition.name}`);
  sections.push('; Generated by treelsp — do not edit');

  if (keywordStrings.length > 0) {
    sections.push('');
    sections.push('; Keywords');
    for (const kw of keywordStrings) {
      sections.push(`${JSON.stringify(kw)} @keyword`);
    }
  }

  if (operatorStrings.length > 0) {
    sections.push('');
    sections.push('; Operators');
    for (const op of operatorStrings) {
      sections.push(`${JSON.stringify(op)} @operator`);
    }
  }

  if (bracketStrings.length > 0) {
    sections.push('');
    sections.push('; Brackets');
    for (const br of bracketStrings) {
      sections.push(`${JSON.stringify(br)} @punctuation.bracket`);
    }
  }

  if (delimiterStrings.length > 0) {
    sections.push('');
    sections.push('; Delimiters');
    for (const dl of delimiterStrings) {
      sections.push(`${JSON.stringify(dl)} @punctuation.delimiter`);
    }
  }

  if (declarationCaptures.length > 0) {
    sections.push('');
    sections.push('; Declarations');
    for (const cap of declarationCaptures) {
      sections.push(cap);
    }
  }

  if (literalCaptures.length > 0) {
    sections.push('');
    sections.push('; Literals');
    for (const cap of literalCaptures) {
      sections.push(cap);
    }
  }

  if (identifierCaptures.length > 0) {
    sections.push('');
    sections.push('; Identifiers');
    for (const cap of identifierCaptures) {
      sections.push(cap);
    }
  }

  sections.push('');
  return sections.join('\n');
}
