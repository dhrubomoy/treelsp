import { describe, it, expect } from 'vitest';
import { generateHighlights } from './highlights.js';
import type { LanguageDefinition } from '../definition/index.js';

type MiniLangRules =
  | 'program' | 'statement' | 'variable_decl' | 'expr_statement'
  | 'expression' | 'binary_expr' | 'identifier' | 'number';

function createMiniLangDefinition(): LanguageDefinition<MiniLangRules> {
  return {
    name: 'MiniLang',
    fileExtensions: ['.mini'],
    entry: 'program',
    word: 'identifier',

    grammar: {
      program: r => r.repeat(r.rule('statement')),
      statement: r => r.choice(r.rule('variable_decl'), r.rule('expr_statement')),
      variable_decl: r => r.seq(
        'let',
        r.field('name', r.rule('identifier')),
        '=',
        r.field('value', r.rule('expression')),
        ';',
      ),
      expr_statement: r => r.seq(r.field('expr', r.rule('expression')), ';'),
      expression: r => r.choice(r.rule('binary_expr'), r.rule('identifier'), r.rule('number')),
      binary_expr: r => r.choice(
        r.prec.left(1, r.seq(r.field('left', r.rule('expression')), r.field('op', '+'), r.field('right', r.rule('expression')))),
        r.prec.left(1, r.seq(r.field('left', r.rule('expression')), r.field('op', '-'), r.field('right', r.rule('expression')))),
        r.prec.left(2, r.seq(r.field('left', r.rule('expression')), r.field('op', '*'), r.field('right', r.rule('expression')))),
        r.prec.left(2, r.seq(r.field('left', r.rule('expression')), r.field('op', '/'), r.field('right', r.rule('expression')))),
      ),
      identifier: r => r.token(/[a-zA-Z_][a-zA-Z0-9_]*/),
      number: r => r.token(/[0-9]+/),
    },

    semantic: {
      program: { scope: 'global' },
      variable_decl: { declares: { field: 'name', scope: 'enclosing' } },
      identifier: { references: { field: 'name', to: 'variable_decl', onUnresolved: 'error' } },
    },

    lsp: {
      $keywords: { 'let': { detail: 'Declare a variable' } },
      variable_decl: {
        completionKind: 'Variable',
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        symbol: { kind: 'Variable', label: (n: any) => n.field('name').text },
      },
    },
  };
}

describe('generateHighlights', () => {
  it('generates header comment', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('; Syntax highlighting for MiniLang');
    expect(result).toContain('; Generated by treelsp');
  });

  it('classifies keywords from $keywords', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('"let" @keyword');
  });

  it('classifies operators', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('"+" @operator');
    expect(result).toContain('"-" @operator');
    expect(result).toContain('"*" @operator');
    expect(result).toContain('"/" @operator');
  });

  it('classifies = as operator', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('"=" @operator');
  });

  it('classifies ; as punctuation delimiter', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('";" @punctuation.delimiter');
  });

  it('captures declaration names with correct highlight group', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('(variable_decl name: (identifier) @variable)');
  });

  it('classifies number token', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('(number) @number');
  });

  it('classifies identifier as fallback variable', () => {
    const result = generateHighlights(createMiniLangDefinition());
    expect(result).toContain('(identifier) @variable');
  });

  it('maps Function completionKind to @function', () => {
    const def: LanguageDefinition<'program' | 'function_decl' | 'identifier'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      word: 'identifier',
      grammar: {
        program: r => r.repeat(r.rule('function_decl')),
        function_decl: r => r.seq('fn', r.field('name', r.rule('identifier')), '(', ')'),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
      semantic: {
        program: { scope: 'global' },
        function_decl: { declares: { field: 'name', scope: 'enclosing' } },
      },
      lsp: {
        function_decl: { completionKind: 'Function' },
      },
    };
    const result = generateHighlights(def);
    expect(result).toContain('(function_decl name: (identifier) @function)');
  });

  it('maps Class completionKind to @type', () => {
    const def: LanguageDefinition<'program' | 'class_decl' | 'identifier'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      word: 'identifier',
      grammar: {
        program: r => r.repeat(r.rule('class_decl')),
        class_decl: r => r.seq('class', r.field('name', r.rule('identifier'))),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
      semantic: {
        program: { scope: 'global' },
        class_decl: { declares: { field: 'name', scope: 'enclosing' } },
      },
      lsp: {
        class_decl: { completionKind: 'Class' },
      },
    };
    const result = generateHighlights(def);
    expect(result).toContain('(class_decl name: (identifier) @type)');
  });

  it('classifies brackets as punctuation.bracket', () => {
    const def: LanguageDefinition<'program' | 'function_decl' | 'identifier'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      word: 'identifier',
      grammar: {
        program: r => r.repeat(r.rule('function_decl')),
        function_decl: r => r.seq('fn', r.field('name', r.rule('identifier')), '(', ')'),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
    };
    const result = generateHighlights(def);
    expect(result).toContain('"(" @punctuation.bracket');
    expect(result).toContain('")" @punctuation.bracket');
  });

  it('classifies alphabetic strings as keywords even without $keywords', () => {
    const def: LanguageDefinition<'program' | 'stmt' | 'identifier'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      word: 'identifier',
      grammar: {
        program: r => r.repeat(r.rule('stmt')),
        stmt: r => r.seq('if', r.rule('identifier')),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
    };
    const result = generateHighlights(def);
    expect(result).toContain('"if" @keyword');
  });

  it('works with no semantic layer', () => {
    const def: LanguageDefinition<'program' | 'identifier' | 'number'> = {
      name: 'Bare',
      fileExtensions: ['.bare'],
      entry: 'program',
      grammar: {
        program: r => r.repeat(r.choice(r.rule('identifier'), r.rule('number'))),
        identifier: r => r.token(/[a-zA-Z_]+/),
        number: r => r.token(/[0-9]+/),
      },
    };
    const result = generateHighlights(def);
    expect(result).toContain('; Syntax highlighting for Bare');
    expect(result).toContain('(number) @number');
  });

  it('works with no lsp layer', () => {
    const def: LanguageDefinition<'program' | 'variable_decl' | 'identifier'> = {
      name: 'NoLsp',
      fileExtensions: ['.nolsp'],
      entry: 'program',
      word: 'identifier',
      grammar: {
        program: r => r.repeat(r.rule('variable_decl')),
        variable_decl: r => r.seq('let', r.field('name', r.rule('identifier'))),
        identifier: r => r.token(/[a-zA-Z_]+/),
      },
      semantic: {
        program: { scope: 'global' },
        variable_decl: { declares: { field: 'name', scope: 'enclosing' } },
      },
    };
    const result = generateHighlights(def);
    // Should still generate declaration capture with default @variable
    expect(result).toContain('(variable_decl name: (identifier) @variable)');
  });

  it('produces sorted deterministic output', () => {
    const result1 = generateHighlights(createMiniLangDefinition());
    const result2 = generateHighlights(createMiniLangDefinition());
    expect(result1).toBe(result2);
  });

  it('classifies string token rules', () => {
    const def: LanguageDefinition<'program' | 'string_literal'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      grammar: {
        program: r => r.repeat(r.rule('string_literal')),
        string_literal: r => r.token(/"[^"]*"/),
      },
    };
    const result = generateHighlights(def);
    expect(result).toContain('(string_literal) @string');
  });

  it('classifies comment token rules', () => {
    const def: LanguageDefinition<'program' | 'comment'> = {
      name: 'TestLang',
      fileExtensions: ['.test'],
      entry: 'program',
      grammar: {
        program: r => r.repeat(r.rule('comment')),
        comment: r => r.token(/\/\/.*/),
      },
    };
    const result = generateHighlights(def);
    expect(result).toContain('(comment) @comment');
  });
});
