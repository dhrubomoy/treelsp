/**
 * LSP server codegen
 * Generates LSP server entry point from language definition
 */

import type { LanguageDefinition } from '../definition/index.js';

/**
 * Generate LSP server entry point
 *
 * Emits a complete Node.js LSP server that:
 * - Creates a vscode-languageserver connection (stdio transport)
 * - Loads the grammar WASM and language definition
 * - Creates a LanguageService using treelsp runtime
 * - Wires LSP protocol events to LanguageService methods
 * - Converts internal types to LSP protocol types
 */
export function generateServer<T extends string>(
  definition: LanguageDefinition<T>
): string {
  const name = definition.name;
  const langId = name.toLowerCase();
  const hasValidation = definition.validation !== undefined;
  const hasLsp = definition.lsp !== undefined;

  const lines: string[] = [];

  // Header
  lines.push(`/**`);
  lines.push(` * LSP server for ${name}`);
  lines.push(` * Generated by treelsp â€” do not edit`);
  lines.push(` */`);
  lines.push(``);

  // Imports
  lines.push(`import {`);
  lines.push(`  createConnection,`);
  lines.push(`  TextDocuments,`);
  lines.push(`  ProposedFeatures,`);
  lines.push(`  TextDocumentSyncKind,`);
  lines.push(`  DiagnosticSeverity,`);
  lines.push(`} from 'vscode-languageserver/node';`);
  lines.push(`import { TextDocument } from 'vscode-languageserver-textdocument';`);
  lines.push(`import { createServer, createDocumentState } from 'treelsp/runtime';`);
  lines.push(`import { resolve, dirname } from 'node:path';`);
  lines.push(`import { fileURLToPath } from 'node:url';`);
  lines.push(`import definition from '../grammar.js';`);
  lines.push(``);

  // Connection setup
  lines.push(`const connection = createConnection(ProposedFeatures.all);`);
  lines.push(`const textDocuments = new TextDocuments(TextDocument);`);
  lines.push(``);

  // WASM path resolution
  lines.push(`const __dirname = dirname(fileURLToPath(import.meta.url));`);
  lines.push(`const wasmPath = resolve(__dirname, 'grammar.wasm');`);
  lines.push(``);

  // Language service
  lines.push(`const service = createServer(definition);`);
  lines.push(``);

  // Document state cache
  lines.push(`const documentStates = new Map();`);
  lines.push(``);

  // Helper: get or create document state
  lines.push(`async function getDocumentState(textDoc) {`);
  lines.push(`  let state = documentStates.get(textDoc.uri);`);
  lines.push(`  if (!state) {`);
  lines.push(`    state = await createDocumentState(wasmPath, {`);
  lines.push(`      uri: textDoc.uri,`);
  lines.push(`      version: textDoc.version,`);
  lines.push(`      languageId: '${langId}',`);
  lines.push(`    }, textDoc.getText());`);
  lines.push(`    documentStates.set(textDoc.uri, state);`);
  lines.push(`  }`);
  lines.push(`  return state;`);
  lines.push(`}`);
  lines.push(``);

  // Helper: severity mapping
  lines.push(`const severityMap = {`);
  lines.push(`  error: DiagnosticSeverity.Error,`);
  lines.push(`  warning: DiagnosticSeverity.Warning,`);
  lines.push(`  info: DiagnosticSeverity.Information,`);
  lines.push(`  hint: DiagnosticSeverity.Hint,`);
  lines.push(`};`);
  lines.push(``);

  // Helper: validate and send diagnostics
  lines.push(`async function validateDocument(textDoc) {`);
  lines.push(`  const state = await getDocumentState(textDoc);`);
  lines.push(`  const diagnostics = service.computeDiagnostics(state);`);
  lines.push(`  connection.sendDiagnostics({`);
  lines.push(`    uri: textDoc.uri,`);
  lines.push(`    version: textDoc.version,`);
  lines.push(`    diagnostics: diagnostics.map(d => ({`);
  lines.push(`      range: d.range,`);
  lines.push(`      severity: severityMap[d.severity],`);
  lines.push(`      message: d.message,`);
  lines.push(`      code: d.code,`);
  lines.push(`      source: d.source ?? '${langId}',`);
  lines.push(`    })),`);
  lines.push(`  });`);
  lines.push(`}`);
  lines.push(``);

  // Initialize
  lines.push(`connection.onInitialize(() => ({`);
  lines.push(`  capabilities: {`);
  lines.push(`    textDocumentSync: TextDocumentSyncKind.Full,`);
  lines.push(`    hoverProvider: true,`);
  lines.push(`    definitionProvider: true,`);
  lines.push(`    referencesProvider: true,`);
  lines.push(`    completionProvider: { resolveProvider: false },`);
  lines.push(`    renameProvider: true,`);
  lines.push(`    documentSymbolProvider: true,`);
  lines.push(`  },`);
  lines.push(`}));`);
  lines.push(``);

  // Document open
  lines.push(`textDocuments.onDidOpen(async (event) => {`);
  lines.push(`  await validateDocument(event.document);`);
  lines.push(`});`);
  lines.push(``);

  // Document change
  lines.push(`textDocuments.onDidChangeContent(async (event) => {`);
  lines.push(`  const state = documentStates.get(event.document.uri);`);
  lines.push(`  if (state) {`);
  lines.push(`    state.update(event.document.getText(), event.document.version);`);
  lines.push(`    service.documents.change(state);`);
  lines.push(`  }`);
  lines.push(`  await validateDocument(event.document);`);
  lines.push(`});`);
  lines.push(``);

  // Document close
  lines.push(`textDocuments.onDidClose((event) => {`);
  lines.push(`  const state = documentStates.get(event.document.uri);`);
  lines.push(`  if (state) {`);
  lines.push(`    service.documents.close(event.document.uri);`);
  lines.push(`    state.dispose();`);
  lines.push(`    documentStates.delete(event.document.uri);`);
  lines.push(`  }`);
  lines.push(`  connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });`);
  lines.push(`});`);
  lines.push(``);

  // Hover
  lines.push(`connection.onHover(async (params) => {`);
  lines.push(`  const textDoc = textDocuments.get(params.textDocument.uri);`);
  lines.push(`  if (!textDoc) return null;`);
  lines.push(`  const state = await getDocumentState(textDoc);`);
  lines.push(`  const result = service.provideHover(state, params.position);`);
  lines.push(`  if (!result) return null;`);
  lines.push(`  return {`);
  lines.push(`    contents: { kind: 'markdown', value: result.contents },`);
  lines.push(`    range: result.range,`);
  lines.push(`  };`);
  lines.push(`});`);
  lines.push(``);

  // Definition
  lines.push(`connection.onDefinition(async (params) => {`);
  lines.push(`  const textDoc = textDocuments.get(params.textDocument.uri);`);
  lines.push(`  if (!textDoc) return null;`);
  lines.push(`  const state = await getDocumentState(textDoc);`);
  lines.push(`  const result = service.provideDefinition(state, params.position);`);
  lines.push(`  if (!result) return null;`);
  lines.push(`  return { uri: result.uri, range: result.range };`);
  lines.push(`});`);
  lines.push(``);

  // References
  lines.push(`connection.onReferences(async (params) => {`);
  lines.push(`  const textDoc = textDocuments.get(params.textDocument.uri);`);
  lines.push(`  if (!textDoc) return [];`);
  lines.push(`  const state = await getDocumentState(textDoc);`);
  lines.push(`  const results = service.provideReferences(state, params.position);`);
  lines.push(`  return results.map(r => ({ uri: r.uri, range: r.range }));`);
  lines.push(`});`);
  lines.push(``);

  // Completion
  lines.push(`connection.onCompletion(async (params) => {`);
  lines.push(`  const textDoc = textDocuments.get(params.textDocument.uri);`);
  lines.push(`  if (!textDoc) return [];`);
  lines.push(`  const state = await getDocumentState(textDoc);`);
  lines.push(`  return service.provideCompletion(state, params.position);`);
  lines.push(`});`);
  lines.push(``);

  // Rename
  lines.push(`connection.onRenameRequest(async (params) => {`);
  lines.push(`  const textDoc = textDocuments.get(params.textDocument.uri);`);
  lines.push(`  if (!textDoc) return null;`);
  lines.push(`  const state = await getDocumentState(textDoc);`);
  lines.push(`  const result = service.provideRename(state, params.position, params.newName);`);
  lines.push(`  if (!result) return null;`);
  lines.push(`  const changes = {};`);
  lines.push(`  for (const [uri, edits] of Object.entries(result.changes)) {`);
  lines.push(`    changes[uri] = edits.map(e => ({ range: e.range, newText: e.newText }));`);
  lines.push(`  }`);
  lines.push(`  return { changes };`);
  lines.push(`});`);
  lines.push(``);

  // Document symbols
  lines.push(`connection.onDocumentSymbol(async (params) => {`);
  lines.push(`  const textDoc = textDocuments.get(params.textDocument.uri);`);
  lines.push(`  if (!textDoc) return [];`);
  lines.push(`  const state = await getDocumentState(textDoc);`);
  lines.push(`  return service.provideSymbols(state);`);
  lines.push(`});`);
  lines.push(``);

  // Start listening
  lines.push(`textDocuments.listen(connection);`);
  lines.push(`connection.listen();`);
  lines.push(``);

  return lines.join('\n');
}

/**
 * Manifest for VS Code extension discovery
 */
export interface TreelspManifest {
  /** Language name (e.g., "MiniLang") */
  name: string;
  /** Language ID for LSP (lowercase, e.g., "minilang") */
  languageId: string;
  /** File extensions including dot (e.g., [".mini"]) */
  fileExtensions: string[];
  /** Path to compiled server entry point, relative to manifest */
  server: string;
}

/**
 * Generate treelsp.json manifest for VS Code extension discovery
 *
 * The manifest tells the VS Code extension:
 * - What language this server handles
 * - Which file extensions to activate on
 * - Where to find the compiled server entry point
 */
export function generateManifest<T extends string>(
  definition: LanguageDefinition<T>
): string {
  const manifest: TreelspManifest = {
    name: definition.name,
    languageId: definition.name.toLowerCase(),
    fileExtensions: definition.fileExtensions,
    server: './server.bundle.cjs',
  };
  return JSON.stringify(manifest, null, 2) + '\n';
}
