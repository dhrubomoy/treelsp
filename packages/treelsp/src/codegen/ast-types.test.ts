import { describe, it, expect } from 'vitest';
import { generateAstTypes } from './ast-types.js';
import type { LanguageDefinition } from '../definition/index.js';

/** Mini-lang-like definition for testing */
function createMiniLangDefinition(): LanguageDefinition<
  'program' | 'statement' | 'variable_decl' | 'expr_statement'
  | 'expression' | 'binary_expr' | 'identifier' | 'number'
> {
  return {
    name: 'MiniLang',
    fileExtensions: ['.mini'],
    entry: 'program',
    word: 'identifier',
    grammar: {
      program: r => r.repeat(r.rule('statement')),
      statement: r => r.choice(
        r.rule('variable_decl'),
        r.rule('expr_statement'),
      ),
      variable_decl: r => r.seq(
        'let',
        r.field('name', r.rule('identifier')),
        '=',
        r.field('value', r.rule('expression')),
        ';',
      ),
      expr_statement: r => r.seq(
        r.field('expr', r.rule('expression')),
        ';',
      ),
      expression: r => r.choice(
        r.rule('binary_expr'),
        r.rule('identifier'),
        r.rule('number'),
      ),
      binary_expr: r => r.prec.left(1, r.seq(
        r.field('left', r.rule('expression')),
        r.field('op', '+'),
        r.field('right', r.rule('expression')),
      )),
      identifier: r => r.token(/[a-zA-Z_][a-zA-Z0-9_]*/),
      number: r => r.token(/[0-9]+/),
    },
  };
}

describe('generateAstTypes', () => {
  it('generates non-empty output', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result.length).toBeGreaterThan(0);
  });

  it('includes generated-by header', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain('AST types for MiniLang');
    expect(result).toContain('Generated by treelsp');
    expect(result).toContain('do not edit');
  });

  it('imports ASTNode from treelsp/runtime', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain("import type { ASTNode } from 'treelsp/runtime'");
  });

  it('generates interface for each rule', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain('export interface ProgramNode extends ASTNode');
    expect(result).toContain('export interface StatementNode extends ASTNode');
    expect(result).toContain('export interface VariableDeclNode extends ASTNode');
    expect(result).toContain('export interface ExprStatementNode extends ASTNode');
    expect(result).toContain('export interface ExpressionNode extends ASTNode');
    expect(result).toContain('export interface BinaryExprNode extends ASTNode');
    expect(result).toContain('export interface IdentifierNode extends ASTNode');
    expect(result).toContain('export interface NumberNode extends ASTNode');
  });

  it('generates typed type field', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain("readonly type: 'program'");
    expect(result).toContain("readonly type: 'variable_decl'");
    expect(result).toContain("readonly type: 'identifier'");
  });

  it('generates typed field accessors for variable_decl', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    // variable_decl has name (identifier) and value (expression) fields
    expect(result).toContain("field(name: 'name'): IdentifierNode");
    expect(result).toContain("field(name: 'value'): ExpressionNode");
  });

  it('generates typed field accessors for expr_statement', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain("field(name: 'expr'): ExpressionNode");
  });

  it('generates typed field accessors for binary_expr', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain("field(name: 'left'): ExpressionNode");
    expect(result).toContain("field(name: 'right'): ExpressionNode");
  });

  it('generates union type', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain('export type MiniLangNode =');
    expect(result).toContain('| ProgramNode');
    expect(result).toContain('| VariableDeclNode');
    expect(result).toContain('| IdentifierNode');
    expect(result).toContain('| NumberNode');
  });

  it('generates type guard', () => {
    const result = generateAstTypes(createMiniLangDefinition());
    expect(result).toContain('export function isNodeType');
    expect(result).toContain("MiniLangNode['type']");
    expect(result).toContain('node.type === type');
  });

  it('handles optional fields in choice branches', () => {
    const def: LanguageDefinition<'root' | 'a' | 'b'> = {
      name: 'Test',
      fileExtensions: ['.test'],
      entry: 'root',
      word: 'a',
      grammar: {
        root: r => r.choice(
          r.field('x', r.rule('a')),
          r.field('y', r.rule('b')),
        ),
        a: r => r.token(/a/),
        b: r => r.token(/b/),
      },
    };
    const result = generateAstTypes(def);
    // Fields from choice branches should be optional (| null)
    expect(result).toContain("field(name: 'x'): ANode | null");
    expect(result).toContain("field(name: 'y'): BNode | null");
  });

  it('handles rules without fields', () => {
    const def: LanguageDefinition<'root' | 'token'> = {
      name: 'Simple',
      fileExtensions: ['.simple'],
      entry: 'root',
      word: 'token',
      grammar: {
        root: r => r.repeat(r.rule('token')),
        token: r => r.token(/[a-z]+/),
      },
    };
    const result = generateAstTypes(def);
    // Root and token should have no field methods
    expect(result).toContain('export interface RootNode extends ASTNode');
    expect(result).toContain("readonly type: 'root'");
    // Should NOT have field() methods for rules without fields
    const rootInterface = result.split('export interface RootNode')[1]?.split('}')[0];
    expect(rootInterface).not.toContain('field(name:');
  });
});
